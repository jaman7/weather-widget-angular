btn-controls.component.html
<div class="map-sidebar">
  <ul class="sidebar-menu" [@expandCollapseHorizontal]="(collapsedSidebarRight$ | async) ? 'final' : 'initial'">
    <ng-container *ngTemplateOutlet="nodes; context: { $implicit: sidebarRightConfig }"></ng-container>
  </ul>
  <div class="open-mapsidebar" [ngClass]="(collapsedSidebarRight$ | async) ? 'open' : ''">
    <app-button [isRound]="true" (btnClick)="openSideBar()">
      <i nz-icon nzType="double-left" [ngClass]="(collapsedSidebarRight$ | async) ? 'open' : ''"></i>
    </app-button>
  </div>
</div>
<ng-template #nodes let-menu>
  <ng-container *ngFor="let item of menu; index as i; trackByIndex">
    <li>
      <p class="title">{{ item.title | translate }}</p>
      <div *ngIf="item?.type === 'button'" class="btn-controls">
        <app-button
          *ngFor="let btn of item.children; trackByIndex"
          [ngClass]="['top-btn']"
          [isRound]="true"
          class="btn-root"
          className="{{ btn?.additionalClass ?? '' }} {{ btn.selected ? 'active' : '' }}"
          [nzTooltipTitle]="'mapData.buttons.' + btn?.tooltipTitle | translate"
          nzTooltipOverlayClassName="tooltip-btn-left"
          nz-tooltip
          [nzTooltipPlacement]="btn?.tooltipPlacement ?? 'left'"
          (btnClick)="onButtonControlAction(btn?.id)"
        >
          <i nz-icon [nzType]="btn?.iconType"></i>
        </app-button>
      </div>
      <nz-radio-group
        *ngIf="item?.type === 'radio-item' && item?.typeCheckbox === 'weather'"
        class="tile-list"
        [(ngModel)]="selectedTileLayer"
        (ngModelChange)="onWeatherLayerChange($event)"
      >
        <label nz-radio *ngFor="let layer of item.children; trackByIndex" [nzValue]="layer">
          {{ layer.name }}
        </label>
      </nz-radio-group>
      <nz-radio-group
        *ngIf="item?.type === 'radio-item' && item?.typeCheckbox === 'tile'"
        class="tile-list"
        [(ngModel)]="selectedBackgroundLayer"
        (ngModelChange)="onTileLayerChange($event)"
      >
        <label nz-radio *ngFor="let layer of item.children; trackByIndex" [nzValue]="layer.value">
          {{ layer.name }}
        </label>
      </nz-radio-group>
    </li>
  </ng-container>
</ng-template>

btn-controls.component.ts
import { Component, HostListener, Input, OnDestroy, OnInit } from '@angular/core';
import Map from 'ol/Map';
import { easeIn, easeOut } from 'ol/easing';
import { Observable, Subscription, concatMap, from, interval, of } from 'rxjs';
import { ExpandCollapseHorizontal } from '@app/shared/animations/animations';
import TileLayer from 'ol/layer/Tile';
import { XYZ } from 'ol/source';
import { MapService } from '@app/components/commons/map/map.service';
import { MapsTilleLayers, sidebarConfig, TileLayerBackground } from './btn-controls.config';
import { CheckboxTypes, ISidebarConfig } from './btn-controls.models';
import { ButtonsControl } from './btn-controls.enums';
const { BTN_HOME, BTN_ZOOM_IN, BTN_ZOOM_OUT } = ButtonsControl;
@Component({
  selector: 'app-btn-controls',
  templateUrl: './btn-controls.component.html',
  animations: [ExpandCollapseHorizontal],
})
export class BtnControlsComponent implements OnInit, OnDestroy {
  @Input() mapView!: Map;
  sidebarRightConfig = sidebarConfig();
  collapsedSidebarRight$: Observable<boolean> = of(true);
  mapsTilleLayers = MapsTilleLayers;
  selectedTileLayer = this.mapsTilleLayers[0];
  selectedBackgroundLayer = TileLayerBackground.find(layer => layer.checked)?.id || 1;
  actions = {
    [BTN_ZOOM_IN]: (): void => {
      this.onZoomIn();
    },
    [BTN_ZOOM_OUT]: (): void => {
      this.onZoomOut();
    },
    [BTN_HOME]: (): void => {
      this.onMapHomeCenter();
    },
  };
  private layerUpdateSubscription!: Subscription;
  constructor(private mapService: MapService) {}
  ngOnInit(): void {
    this.mapView.addLayer(this.selectedTileLayer.tile);
    this.startLayerUpdate();
  }
  ngOnDestroy(): void {
    this.sidebarRightConfig = [];
    this.sidebarRightConfig = [];
    if (this.layerUpdateSubscription) this.layerUpdateSubscription.unsubscribe();
  }
  startLayerUpdate(): void {
    this.layerUpdateSubscription = interval(60000).subscribe(() => {
      this.updateSelectedTileLayer();
    });
  }
  updateSelectedTileLayer(): void {
    this.mapView.getLayers().forEach(layer => {
      if (layer === this.selectedTileLayer.tile && layer instanceof TileLayer) {
        const tileLayer = layer as TileLayer;
        const source = tileLayer.getSource();
        if (source instanceof XYZ) source.refresh();
      }
    });
  }
  onButtonControlAction(id: string): void {
    if (id in this.actions) this.actions[id]();
  }
  onLayerChange(item: ISidebarConfig | number, type: CheckboxTypes): void {
    if (type === 'tile') {
      this.onWeatherLayerChange(item as ISidebarConfig);
    } else {
      this.onTileLayerChange(item as number);
    }
  }
  onWeatherLayerChange(selectedLayer: ISidebarConfig): void {
    this.mapsTilleLayers.forEach(layer => {
      if (this.mapView.getLayers().getArray().includes(layer.tile)) this.mapView.removeLayer(layer.tile);
    });
    this.mapView.addLayer(selectedLayer.tile);
    this.mapService.updateLegendLayer(selectedLayer.name);
  }
  onTileLayerChange(layerId: number): void {
    this.mapService.updateTileLayer(layerId);
  }
  onZoomIn(): void {
    this.animateZoom(1);
  }
  onZoomOut(): void {
    this.animateZoom(-1);
  }
  onMapHomeCenter(): void {
    this.mapService.mapHomePosition$.next(true);
    setTimeout(() => {
      this.mapService.mapHomePosition$.next(false);
    }, 20);
  }
  animateZoom(factor: number): void {
    const view = this.mapView.getView();
    view.animate({ zoom: view.getZoom() + factor, easing: factor > 0 ? easeIn : easeOut, duration: 500 });
  }
  openSideBar(): void {
    this.collapsedSidebarRight$ = from(this.collapsedSidebarRight$).pipe(concatMap(content => of(!content)));
  }
  @HostListener('document:click', ['$event.target'])
  handleOutsideClick(target: HTMLElement): void {
    if (!target.closest('.map-sidebar')) {
      this.collapsedSidebarRight$ = of(false);
    }
  }
}

btn-controls.config.ts
import { OSM, XYZ } from 'ol/source';
import TileLayer from 'ol/layer/Tile';
import { API_KEY } from '@app/components/commons/map/map.constants';
import { ButtonsControl, MapButtonsIcons, MapButtonsTooltip } from './btn-controls.enums';
import { ISidebarConfig } from './btn-controls.models';
const { BTN_HOME, BTN_ZOOM_IN, BTN_ZOOM_OUT } = ButtonsControl;
const { HOME_TOOLTIP, ZOOM_IN_TOOLTIP, ZOOM_OUT_TOOLTIP } = MapButtonsTooltip;
const { ICON_HOME, ICON_ZOOM_IN, ICON_ZOOM_OUT } = MapButtonsIcons;
export const MapsTilleLayers = [
  {
    name: 'precipitation',
    tile: new TileLayer({
      source: new XYZ({
        url: https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${API_KEY},
        attributions: '&copy; <a href="https://openweathermap.org/">OpenWeatherMap</a>',
      }),
      opacity: 1,
    }),
  },
  {
    name: 'temp',
    tile: new TileLayer({
      source: new XYZ({
        url: https://tile.openweathermap.org/map/temp_new/{z}/{x}/{y}.png?appid=${API_KEY},
        attributions: '&copy; <a href="https://openweathermap.org/">OpenWeatherMap</a>',
      }),
      opacity: 1,
    }),
  },
  {
    name: 'wind',
    tile: new TileLayer({
      source: new XYZ({
        url: https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid=${API_KEY},
        attributions: '&copy; <a href="https://openweathermap.org/">OpenWeatherMap</a>',
      }),
      opacity: 1,
    }),
  },
  {
    name: 'clouds',
    tile: new TileLayer({
      source: new XYZ({
        url: https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${API_KEY},
        attributions: '&copy; <a href="https://openweathermap.org/">OpenWeatherMap</a>',
      }),
      opacity: 1,
    }),
  },
  {
    name: 'pressure',
    tile: new TileLayer({
      source: new XYZ({
        url: https://tile.openweathermap.org/map/pressure_new/{z}/{x}/{y}.png?appid=${API_KEY},
        attributions: '&copy; <a href="https://openweathermap.org/">OpenWeatherMap</a>',
      }),
      opacity: 1,
    }),
  },
];
export const TileLayerBackground: ISidebarConfig[] = [
  {
    value: 0,
    checked: false,
    name: 'OSM',
    source: new OSM(),
    type: 'radio-item',
  },

  {
    value: 1,
    checked: true,
    name: 'Light',
    source: new OSM({
      url: 'https://cartodb-basemaps-1.global.ssl.fastly.net/light_all/{z}/{x}/{y}{r}.png',
    }),
    type: 'radio-item',
  },
  {
    value: 2,
    checked: false,
    name: 'Dark',
    source: new OSM({
      url: 'https://cartodb-basemaps-1.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{r}.png',
    }),
    type: 'radio-item',
  },
];
export const controlConfig: ISidebarConfig[] = [
  {
    name: BTN_HOME,
    id: BTN_HOME,
    tooltipTitle: HOME_TOOLTIP,
    iconType: ICON_HOME,
    tooltipPlacement: 'top',
  },
  {
    name: BTN_ZOOM_IN,
    id: BTN_ZOOM_IN,
    tooltipTitle: ZOOM_IN_TOOLTIP,
    iconType: ICON_ZOOM_IN,
    tooltipPlacement: 'top',
  },
  {
    name: BTN_ZOOM_OUT,
    id: BTN_ZOOM_OUT,
    tooltipTitle: ZOOM_OUT_TOOLTIP,
    iconType: ICON_ZOOM_OUT,
    tooltipPlacement: 'top',
  },
];
export const sidebarConfig = (): ISidebarConfig[] => [
  {
    title: 'mapData.sidebar.controls',
    type: 'button',
    children: controlConfig,
  },
  { title: 'mapData.sidebar.weatherConditions', type: 'radio-item', typeCheckbox: 'weather', children: MapsTilleLayers },
  { title: 'mapData.sidebar.styleTile', type: 'radio-item', typeCheckbox: 'tile', children: TileLayerBackground },
];

btn-controls.enums.ts
export enum ButtonsControl {
  BTN_HOME = 'home',
  BTN_ZOOM_IN = 'zoom-in',
  BTN_ZOOM_OUT = 'zoom-out',
}
export enum MapButtonsTooltip {
  HOME_TOOLTIP = 'home',
  ZOOM_IN_TOOLTIP = 'zoomIn',
  ZOOM_OUT_TOOLTIP = 'zoomOut',
}
export enum MapButtonsIcons {
  ICON_HOME = 'home',
  ICON_ZOOM_IN = 'plus-circle',
  ICON_ZOOM_OUT = 'minus-circle',
}

btn-controls.models.ts
import TileLayer from 'ol/layer/Tile';
import { OSM } from 'ol/source';
export type BtnTypes = 'button' | 'radio' | 'radio-item';
export type CheckboxTypes = 'weather' | 'tile';
export type TypesTooltipPlacement =
  | 'top'
  | 'left'
  | 'right'
  | 'bottom'
  | 'topLeft'
  | 'topRight'
  | 'bottomLeft'
  | 'bottomRight'
  | 'leftTop'
  | 'leftBottom'
  | 'rightTop'
  | 'rightBottom'
  | Array<string>;
export interface ISidebarConfig {
  id?: number | string;
  level?: number;
  name?: string;
  title?: string;
  icon?: string;
  tooltipTitle?: string;
  tooltipPlacement?: TypesTooltipPlacement;
  additionalClass?: string;
  iconType?: string;
  type?: BtnTypes;
  typeCheckbox?: CheckboxTypes;
  source?: OSM;
  tile?: TileLayer;
  checked?: boolean;
  value?: number;
  children?: ISidebarConfig[];
}

map-legend.component.html
<ng-container *ngIf="legend && getScaleDetails(legend) as scaleDetails">
  <div class="legend-container">
    <span class="legend-title">{{ scaleDetails.title }}</span>
    <div class="legend-gradient" style="width: 260px">
      <div class="horizontal-gradient-line" [ngStyle]="{ backgroundImage: scaleDetails.gradient }"></div>
      <div class="legend-dividers">
        <span class="dividers" *ngFor="let divider of scaleDetails.dividers; trackByIndex">{{ divider }}</span>
      </div>
    </div>
  </div>
</ng-container>

map-legend.component.ts
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';
import { LegendConfig } from './map-legend.config';
import { ILegend } from './map-legend.models';
@Component({
  selector: 'app-map-legend',
  templateUrl: './map-legend.component.html',
})
export class MapLegendComponent implements OnChanges {
  @Input() legend: string;
  scaleDetails: { [name: string]: ILegend } = {};
  ngOnChanges(changes: SimpleChanges): void {
    if (changes.legend) {
      this.scaleDetails = this.getScaleDetails(this.legend);
    }
  }
  getScaleDetails(layerName: string): any {
    return LegendConfig[layerName] || null;
  }
}

map-legend.config.ts
import { ILegend } from './map-legend.models';
export const LegendConfig: { [name: string]: ILegend } = {
  temp: {
    title: 'Temperature, °C',
    gradient:
      'linear-gradient(to right, rgb(159, 85, 181) 0%, rgb(44, 106, 187) 8.75%, rgb(82, 139, 213) 12.5%, rgb(103, 163, 222) 18.75%, rgb(142, 202, 240) 25%, rgb(155, 213, 244) 31.25%, rgb(172, 225, 253) 37.5%, rgb(194, 234, 255) 43.75%, rgb(255, 255, 208) 50%, rgb(254, 248, 174) 56.25%, rgb(254, 232, 146) 62.5%, rgb(254, 226, 112) 68.75%, rgb(253, 212, 97) 75%, rgb(244, 168, 94) 82.5%, rgb(244, 129, 89) 87.5%, rgb(244, 104, 89) 93.75%, rgb(244, 76, 73) 100%)',
    dividers: [-40, -20, 0, 20, 40],
  },
  pressure: {
    title: 'Pressure, hPa',
    gradient:
      'linear-gradient(to right, rgb(0, 115, 255) 0%, rgb(0, 170, 255) 8.35059%, rgb(75, 208, 214) 24.9192%, rgb(141, 231, 199) 41.4879%, rgb(176, 247, 32) 49.7722%, rgb(240, 184, 0) 58.0565%, rgb(251, 85, 21) 74.6251%, rgb(243, 54, 59) 91.1938%, rgb(198, 0, 0) 100%)',
    dividers: [950, 980, 1010, 1040, 1070],
  },
  wind: {
    title: 'Wind speed, m/s',
    gradient:
      'linear-gradient(to left, rgb(158, 128, 177), rgba(116, 76, 172, 0.9), rgb(164, 123, 170), rgba(170, 128, 177, 0.84), rgba(176, 128, 177, 0.71), rgba(170, 128, 177, 0.54), rgba(170, 128, 177, 0.44), rgba(255, 255, 0, 0))',
    dividers: [0, 2, 3, 6, 12, 25, 50, 100],
  },
  clouds: {
    title: 'Clouds, %',
    gradient:
      'linear-gradient(to right, rgba(247, 247, 255, 0) 0%, rgba(251, 247, 255, 0) 10%, rgba(244, 248, 255, 0.1) 20%, rgba(240, 249, 255, 0.2) 30%, rgba(221, 250, 255, 0.4) 40%, rgba(224, 224, 224, 0.9) 50%, rgba(224, 224, 224, 0.76) 60%, rgba(228, 228, 228, 0.9) 70%, rgba(232, 232, 232, 0.9) 80%, rgb(214, 213, 213) 90%, rgb(210, 210, 210) 95%, rgb(183, 183, 183) 100%)',
    dividers: [0, 25, 50, 75, 100],
  },
  precipitation: {
    title: 'Precipitation, mm/h',
    gradient:
      'linear-gradient(to left, rgb(170, 43, 195), rgb(255, 0, 146), rgb(255, 0, 100), rgb(255, 0, 0), rgb(255, 91, 0), rgb(255, 150, 0), rgb(255, 205, 0), rgb(239, 248, 0), rgb(0, 70, 0), rgb(0, 90, 0), rgb(0, 160, 0), rgb(0, 211, 0), rgb(0, 250, 100), rgba(0, 0, 0, 0))',
    dividers: [0, 0.5, 1, 2, 4, 6, 7, 10, 12, 14, 16, 24, 32, 60],
  },
};

map-legend.models.ts
export interface ILegend {
  title: string;
  gradient: string;
  dividers: number[];
}

maps-popup.component.html
<div #popup id="popup" class="ol-popup">
  <app-button class="button-close" [isRound]="true" tooltipTitle="mapData.buttons.close" (btnClick)="closePopup()">
    <i nz-icon nzType="close"></i>
  </app-button>
  <div *ngIf="weatherData$ | async as data">
    <p class="text">Temperature: {{ data.temp }}°C</p>
    <p class="orange-text m-0">Wind: {{ data.wind }} m/s</p>
    <p class="orange-text m-0">Cloud cover: {{ data.clouds }}%</p>
    <p class="orange-text m-0">Pressure: {{ data.pressure }} hPa</p>
  </div>
</div>

maps-popup.component.scss
.ol-popup {
  position: absolute;
  background-color: var(--color-white);
  padding: 5px 42px 5px 5px;
  border-radius: 5px;
  min-width: 150px;
  font-size: 12px;
  color: var(--color-orange);
  width: max-content;
  box-shadow: 0 0 6px 0 var(--shadow-color) !important;
  & .text {
    margin-bottom: 0.1rem;
  }
  & .button-close {
    position: absolute;
    top: 5px;
    right: 5px;
  }
}

maps-popup.component.ts
import { AfterViewInit, Component, ElementRef, Input, OnDestroy, ViewChild } from '@angular/core';
import Map from 'ol/Map';
import Overlay from 'ol/Overlay';
import { of, Observable } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { toLonLat } from 'ol/proj';
import VectorLayer from 'ol/layer/Vector';
import VectorSource from 'ol/source/Vector';
import { Feature } from 'ol';
import { Point } from 'ol/geom';
import Style from 'ol/style/Style';
import Icon from 'ol/style/Icon';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { WeatherPopupService } from './maps-popup.service';
@UntilDestroy()
@Component({
  selector: 'app-maps-popup',
  templateUrl: './maps-popup.component.html',
  styleUrl: './maps-popup.component.scss',
})
export class MapPopupComponent extends WeatherPopupService implements AfterViewInit, OnDestroy {
  @ViewChild('popup') popupEl: ElementRef;
  @Input() mapView: Map;
  weatherData$: Observable<any> = of(null);
  private overlay: Overlay;
  private markerLayer: VectorLayer<VectorSource>;
  private currentMarker: Feature;
  ngAfterViewInit(): void {
    this.setupPopup();
  }
  ngOnDestroy(): void {
    if (this.overlay) this.mapView.removeOverlay(this.overlay);
    if (this.markerLayer) this.mapView.removeLayer(this.markerLayer);
  }
  setupPopup(): void {
    this.overlay = new Overlay({
      element: this.popupEl.nativeElement,
      offset: [0, -13],
    });
    this.mapView.addOverlay(this.overlay);
    this.markerLayer = new VectorLayer({
      source: new VectorSource(),
    });
    this.mapView.addLayer(this.markerLayer);
    this.mapView.on('singleclick', event => {
      const { coordinate } = event;
      const [lon, lat] = toLonLat(coordinate);
      this.weatherData$ = this.getWeatherData(lat, lon).pipe(
        untilDestroyed(this),
        map(data => ({
          id: data.id,
          wind: data.wind.speed,
          temp: data.main.temp,
          clouds: data.clouds.all,
          pressure: data.main.pressure,
          sys: data.sys,
        })),
        catchError((): any => of(false))
      );
      this.addMarker(coordinate);
      this.overlay.setPosition(coordinate);
      const popupRect = this.popupEl.nativeElement.getBoundingClientRect();
      const offsetX = -popupRect.width / 2;
      const offsetY = popupRect.height + 30;
      this.overlay.setOffset([offsetX, -offsetY]);
    });
  }
  addMarker(coordinate: number[]): void {
    if (this.currentMarker) {
      this.markerLayer.getSource().removeFeature(this.currentMarker);
    }
    const marker = new Feature({
      geometry: new Point(coordinate),
    });
    marker.setStyle(
      new Style({
        image: new Icon({
          anchor: [0.5, 1],
          src: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
          scale: 0.05,
        }),
      })
    );
    this.markerLayer.getSource().addFeature(marker);
    this.currentMarker = marker;
  }
  closePopup(): void {
    this.overlay.setPosition(undefined);
    if (this.currentMarker) {
      this.markerLayer.getSource().removeFeature(this.currentMarker);
      this.currentMarker = null;
    }
  }
}

maps-popup.service.ts
import { Injectable } from '@angular/core';
import { HttpService } from '@app/core';
import { Observable } from 'rxjs';
import { IParams } from '@app/core/http/http.model';
import { API_KEY } from '@app/components/commons/map/map.constants';
@Injectable({
  providedIn: 'root',
})
export class WeatherPopupService extends HttpService {
  private baseUrl = 'https://api.openweathermap.org/data/2.5/weather';
  getWeatherData(lat: number, lon: number): Observable<any> {
    const params: IParams = {
      lat,
      lon,
      appid: API_KEY,
      units: 'metric',
    };
    return this.get(this.baseUrl, { params }, true);
  }
}

map-view.component.ts
import { Component, OnInit, ChangeDetectionStrategy, Input, ElementRef } from '@angular/core';
import Map from 'ol/Map';
import { UntilDestroy } from '@ngneat/until-destroy';
@UntilDestroy()
@Component({
  selector: 'app-map-view',
  template: '',
  styles: [':host { width: 100%; height: 100%; display: block; }'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class MapViewComponent implements OnInit {
  @Input() mapView: Map;
  constructor(private elementRef: ElementRef) {}
  ngOnInit(): void {
    this.mapView.setTarget(this.elementRef.nativeElement);
  }
}

mouse-position.ts
import { Component, ChangeDetectionStrategy, Input, ElementRef, AfterViewInit } from '@angular/core';
import Map from 'ol/Map';
import MousePosition from 'ol/control/MousePosition';
import { toStringXY } from 'ol/coordinate';
import { UntilDestroy } from '@ngneat/until-destroy';
import { MapSourceClass, TypeEPSG } from '../map.enums';
const { EPSG4326 } = TypeEPSG;
const { MOUSE_POSITION_CONTROL } = MapSourceClass;
@UntilDestroy()
@Component({
  selector: 'app-mouse-position',
  template: `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class MapMousePositionComponent implements AfterViewInit {
  @Input() mapView: Map;
  @Input() positionTemplate?: string;
  control?: MousePosition;
  constructor(private element: ElementRef) {}
  ngAfterViewInit(): void {
    if (this.mapView) {
      setTimeout(() => {
        this.control = new MousePosition({
          projection: EPSG4326,
          className: MOUSE_POSITION_CONTROL,
          coordinateFormat: (coordinates: number[]): string => toStringXY(coordinates, 6),
          target: this.element.nativeElement,
        });
        this.mapView.addControl(this.control);
      }, 1);
    }
  }
}

scaleline.component.ts
import { Component, OnInit, ChangeDetectionStrategy, Input, ElementRef } from '@angular/core';
import Map from 'ol/Map';
import ScaleLine from 'ol/control/ScaleLine';
import { UntilDestroy } from '@ngneat/until-destroy';
@UntilDestroy()
@Component({
  selector: 'app-scaleline',
  template: `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class MapScalelineComponent implements OnInit {
  @Input() mapView: Map;
  control?: ScaleLine;
  constructor(private elementRef: ElementRef) {}
  ngOnInit(): void {
    this.control = new ScaleLine({
      bar: true,
      text: true,
      minWidth: 125,
      target: this.elementRef.nativeElement,
    });
    this.mapView.addControl(this.control);
  }
}

map.component.html
<div class="map-component">
  <app-btn-controls [mapView]="mapView" />
  <div class="main-map">
    <div class="map-container" [style.height]="height">
      <app-map-view class="map-view" [mapView]="mapView" tabindex="0" />
      <app-scaleline class="scaleline" [mapView]="mapView" />
      <app-mouse-position class="mouse-position" [mapView]="mapView" />
      <app-map-legend [legend]="selectedLayerForLegend" />
      <app-maps-popup [mapView]="mapView" />
    </div>
  </div>
</div>

map.component.ts
import { Component, EventEmitter, Input, NgZone, OnDestroy, OnInit, Output } from '@angular/core';
import { View } from 'ol';
import TileLayer from 'ol/layer/Tile';
import VectorImageLayer from 'ol/layer/VectorImage';
import Map from 'ol/Map';
import { OSM } from 'ol/source';
import VectorSource from 'ol/source/Vector';
import { defaults as defaultControls } from 'ol/control';
import { tap } from 'rxjs';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { easeOut } from 'ol/easing';
import { MapConsts, ViewOptions } from './map.constants';
import { MapService } from './map.service';
import { TileLayerBackground } from './components/btn-controls/btn-controls.config';
@UntilDestroy()
@Component({
  selector: 'app-map',
  templateUrl: './map.component.html',
})
export class MapComponent implements OnInit, OnDestroy {
  @Input() height = '50vh';
  @Output() mapReady = new EventEmitter<Map>();
  mapView!: Map;
  vectorSource = new VectorSource();
  selectedLayerForLegend = '';
  tileLayer = new TileLayer({
    source: new OSM(),
  });
  vectorLayerTop = new VectorImageLayer({
    source: this.vectorSource,
  });
  constructor(
    private zone: NgZone,
    private mapService: MapService
  ) {}
  ngOnInit(): void {
    if (!this.mapView) {
      this.zone.runOutsideAngular(() => {
        this.initializeMap();
        this.subscribeToMapService();
      });
    }
    setTimeout(() => this.mapReady.emit(this.mapView), 0);
  }
  ngOnDestroy(): void {
    this.cleanupMap();
  }
  initializeMap(): void {
    this.mapView = new Map({
      view: new View({ ...ViewOptions }),
      controls: defaultControls({ attribution: false }),
      layers: [this.tileLayer, this.vectorLayerTop],
      target: MapConsts.targetClassName,
    });
    this.mapView.updateSize();
  }
  subscribeToMapService(): void {
    const { selectedTileLayerBackground$, mapHomePosition$, selectedLayerForLegend$ } = this.mapService;
    mapHomePosition$
      .pipe(
        untilDestroyed(this),
        tap(() => this.resetMapPosition())
      )
      .subscribe();
    selectedTileLayerBackground$
      .pipe(
        untilDestroyed(this),
        tap(index => this.updateTileLayer(index))
      )
      .subscribe();
    selectedLayerForLegend$
      .pipe(
        untilDestroyed(this),
        tap(name => {
          this.selectedLayerForLegend = name;
        })
      )
      .subscribe();
  }
  updateTileLayer(index: number): void {
    if (this.tileLayer && index >= 0) {
      this.tileLayer.setSource(TileLayerBackground[index].source);
    }
  }
  resetMapPosition(): void {
    const homeView = new View(ViewOptions);
    this.mapView.getView().animate({
      center: homeView.getCenter(),
      zoom: homeView.getZoom(),
      duration: 1000,
      easing: easeOut,
    });
    this.mapView.updateSize();
  }
  cleanupMap(): void {
    this.mapView.setTarget(null);
    this.vectorLayerTop.getSource().clear();
  }
}

map.constants.ts
import { fromLonLat } from 'ol/proj';
import { TypeEPSG } from './map.enums';
const { EPSG3857 } = TypeEPSG;
export const API_KEY = '33e67a9b2d05b12d29b27e39b1d4719a';
export const ViewOptions = {
  center: fromLonLat([-73.935242, 40.73061]),
  zoom: 7,
  smoothResolutionConstraint: false,
  constrainResolution: true,
  showFullExtent: true,
  projection: EPSG3857,
  pixelRatio: 1,
};
export const MapConsts = {
  targetClassName: 'ol-map',
  paddingOfCenterCluster: { padding: [30, 30, 30, 30] },
  noPadding: { padding: [0, 0, 0, 0] },
  tileLayerIndex: 1,
};

map.enums.ts
export enum TypeEPSG {
  EPSG4326 = 'EPSG:4326',
  EPSG3857 = 'EPSG:3857',
}
export enum MapSourceClass {
  MOUSE_POSITION_CONTROL = 'mouseposition-control',
  NBSP = '&nbsp;',
}

map.module.ts
import { NgModule } from '@angular/core';
import { SharedModule } from '@app/shared';
import { DecimalPipe } from '@angular/common';
import { FullscreenOverlayContainer, OverlayContainer } from '@angular/cdk/overlay';
import { FormsModule } from '@angular/forms';
import { MapComponent } from './map.component';
import { MapViewComponent } from './components/map-view.component';
import { MapScalelineComponent } from './components/scaleline.component';
import { MapMousePositionComponent } from './components/mouse-position';
import { BtnControlsComponent } from './components/btn-controls/btn-controls.component';
import { ButtonModule } from '../button/button.module';
import { MapLegendComponent } from './components/map-legend/map-legend.component';
import { MapPopupComponent } from './components/maps-popup/maps-popup.component';
@NgModule({
  declarations: [
    MapComponent,
    BtnControlsComponent,
    MapViewComponent,
    MapScalelineComponent,
    MapMousePositionComponent,
    MapLegendComponent,
    MapPopupComponent,
  ],
  imports: [SharedModule, ButtonModule, FormsModule],
  providers: [DecimalPipe, { provide: OverlayContainer, useClass: FullscreenOverlayContainer }],
  exports: [MapComponent],
})
export class MapModule {}

map.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class MapService {
  selectedTileLayerBackground$: BehaviorSubject<number> = new BehaviorSubject(1);
  mapHomePosition$: BehaviorSubject<boolean> = new BehaviorSubject(false);
  selectedLayerForLegend$: BehaviorSubject<string> = new BehaviorSubject('precipitation');
  updateTileLayer(layerId: number): void {
    this.selectedTileLayerBackground$.next(layerId);
  }
  updateLegendLayer(name: string): void {
    this.selectedLayerForLegend$.next(name);
  }
}

przekształć na react typscipt tsx

serwis HttpService z serwisu core\http\http.service.tsx
import const serwis = new HttpService(');
 
zamiast rxjs reactowe rozwiązania

dobre najlepsze praktyki, wydajność