map-search.component.html
<div class="map-search">
  <div class="input-container">
    <input
      type="text"
      [ngModel]="query"
      (ngModelChange)="handleInputChange($event)"
      aria-label="dsfdsf"
      placeholder="Search for a city..."
    />
    <!-- {query && <MdClear class="clear-icon" onClick={handleClearInput} />} -->
  </div>
  <div *ngIf="loading" class="loading">Loading...</div>
  <div *ngIf="error" class="error">{{ error }}</div>

  <ul *ngIf="suggestions?.length" class="suggestions-list scroll">
    <li *ngFor="let suggestion of suggestions; index as i; trackByIndex" (click)="handleSelectSuggestion(suggestion)">
      {{ suggestion.displayName }}
    </li>
  </ul>
</div>


map-search.component.ts
import { Component, Input, OnDestroy, OnInit } from '@angular/core';
import Map from 'ol/Map';
import VectorImageLayer from 'ol/layer/VectorImage';
import { Feature } from 'ol';
import { fromLonLat } from 'ol/proj';
import { Circle as CircleGeom } from 'ol/geom';
import { Style } from 'ol/style';
import { catchError, debounceTime, of, Subject, switchMap, tap } from 'rxjs';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { Colors } from '../../map.constants';
import { styleFill, styleStroke } from '../../map.helpers';
import { MapSearchService } from './map-search.service';
import { MapService } from '../../map.service';

@UntilDestroy()
@Component({
  selector: 'app-map-search',
  templateUrl: './map-search.component.html',
})
export class MapSearchComponent implements OnInit, OnDestroy {
  @Input() mapView!: Map;

  query: string = '';

  suggestions: any[] = [];

  loading: boolean = false;

  error: string = '';

  isSelecting: boolean = false;

  private searchTerms$ = new Subject<string>();

  constructor(
    private mapService: MapService,
    public mapSearchService: MapSearchService
  ) {}

  ngOnInit(): void {
    this.searchTerms$
      .pipe(
        debounceTime(1000),
        switchMap((term: string) => {
          this.fetchSuggestions(term as string);
          return of(null);
        }),
        untilDestroyed(this)
      )
      .subscribe();
  }

  ngOnDestroy(): void {
    this.query = '';
    this.suggestions = [];
    this.mapService.searchData$.next(null);
    this.getCurrentVectorImageLayer()?.getSource()?.clear();
  }

  fetchSuggestions(query: string): void {
    this.loading = true;
    this.mapSearchService
      .getData(query)
      .pipe(
        tap(data => {
          this.suggestions = data;
          this.loading = false;
        }),
        catchError(() => {
          this.loading = false;
          this.error = 'Failed to fetch suggestions.';
          return of([]);
        })
      )
      .subscribe();
  }

  getCurrentVectorImageLayer(): VectorImageLayer | null {
    return (
      this.mapView
        .getLayers()
        .getArray()
        .find(layer => layer instanceof VectorImageLayer) || null
    );
  }

  handleInputChange(event: string): void {
    const input = event;
    this.isSelecting = false;
    this.query = input;
    if (this.query.length > 2) {
      this.searchTerms$.next(this.query);
    } else {
      this.suggestions = [];
    }
  }

  handleSelectSuggestion(suggestion: any): void {
    const { longitude, latitude } = suggestion?.properties?.coordinates || {};
    const view = this.mapView.getView();
    const targetCoordinates = fromLonLat([parseFloat(longitude), parseFloat(latitude)]);
    const currentLayer = this.getCurrentVectorImageLayer();
    const vectorSource = currentLayer?.getSource();
    vectorSource?.clear();
    const radius = 500;
    const circleFeature = new Feature({
      geometry: new CircleGeom(targetCoordinates, radius),
    });
    circleFeature.setStyle(
      new Style({
        fill: styleFill(Colors.blue, 0.1),
        stroke: styleStroke(Colors.blue),
      })
    );
    vectorSource?.addFeature(circleFeature);
    view.animate({
      center: targetCoordinates,
      zoom: 15,
      duration: 1000,
      easing: t => t * (2 - t),
    });

    this.isSelecting = true;
    this.query = suggestion.displayName;
    this.mapService.searchData$.next({ longitude, latitude, city: suggestion?.properties?.name ?? '' });
    this.suggestions = [];
  }

  handleClearInput(): void {
    this.query = '';
    this.suggestions = [];
    this.mapService.searchData$.next(null);
    this.getCurrentVectorImageLayer()?.getSource()?.clear();
  }
}


map-search.models.ts
export interface ISearchData {
  city?: string;
  latitude?: number;
  longitude?: number;
}


map-search.service.ts
import { Injectable } from '@angular/core';
import { HttpService } from '@app/core';
import { map, Observable } from 'rxjs';
import { MAPBOX_API_KEY } from '@app/components/commons/map/map.constants';
import { ISearchData } from './map-search.models';

@Injectable({
  providedIn: 'root',
})
export class MapSearchService extends HttpService {
  private baseUrl = 'https://api.mapbox.com/search/geocode/v6/forward';

  getData(searchTerm: string): Observable<ISearchData[]> {
    const params = {
      q: searchTerm,
      limit: 10,
      access_token: MAPBOX_API_KEY,
    };
    return this.get<ISearchData[]>(this.baseUrl, { params }, true).pipe(
      map((data: any) => {
        const { features } = data || {};
        return (
          features?.map((item: any) => {
            const { id, geometry, properties } = item || {};
            return {
              id,
              geometry,
              properties,
              displayName: properties?.full_address,
            };
          }) ?? []
        );
      })
    );
  }
}


